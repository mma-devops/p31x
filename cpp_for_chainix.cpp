// Подключение библиотеки которая позволяет нам выводить/вводить данные.
#include <iostream>

// библиотэчка для работы со строками
#include <string>

// Объявление простронства имён std, чтоб далее не писать std::
using namespace std;

// ФУНКЦЫИИИ)))
// сначала выбираем тип возвращаемого значения, потом название функции
// потом создаём переменную (в скобочках))00) которая работает строго внутри данной функции
int funcia_xd(int a, int b, string c)
{
    // чето делаем))
    a = a + b;
    // возвращаем значение в место вызова функции
    return a;
}

// void функция (БЕЗДНА) нече не возвращает) (строение функции такое же)
void gawnina(string a)
{
    cout << a << ' ' << "yarick";
}

// Инициализация главной функции main с нашим кодом.
int main()
{

    // Объявление переменных с их типом данных.
    int a = 0;

    // float и double по сути одно и то же, только double хранит больше чисел после запятой.
    float b = 3.14;
    double c = 3.1415;

    string d = "abc";

    // Тип переменных char состоить только из одного символа в одинарных кавычках.
    char e = 'e';

    // Чтобы ввести данные с клавы нужно создать перемнную и командой cin (character input) ввести наши данные. !!! (ВНИМАНИЕ НА НАПРАВЛЕНИЕ СТРЕЛОК)
    int f;
    cin >> f;

    // Вывод данных осуществляется командой cout (character output) !!! (ВНИМАНИЕ НА НАПРАВЛЕНИЕ СТРЕЛОК)

    cout << a << " " << b << endl;
    cout << "123\n";

    // Функция printf() - это аналог f-строки из пайтона, только вместо переменных в строке мы пишем их идентификатор. Инструкцию с каждым я скину позже.
    printf("%u lkhjglkjgklj;h %d", a, c);

    // Значения типов:

    // %d — десятичное знаковое число, тип по умолчанию int.;
    // %f — числа с плавающей запятой, тип по умолчанию double.;
    // %s — вывод строки.;
    // %% — символ для вывода знака процента (%), используется для возможности вывода символов процента в строке printf, всегда используется в виде %%.

    // Объявление переменных в одну строку.
    int a, b, c;

    // C++ позволяет нам вводить данные через пробел.
    cin >> a >> b >> c;

    printf("%u %u %u", a, b, c);

    // Условия в C++ абсолютно такие же как и в пайтоне, только условие у нас обязательно стоит в скобках.

    int a = 2;
    if (a > 1)
    {
        // endl - это аналог "\n", используется по желанию.
        cout << "a > 1" << endl;
    }
    // elif пишется как else if
    else if (a < 1)
    {
        cout << "a < 1\n";
    }
    // else такой же.
    else
    {
        cout << "ya loh\n";
    }

    // Цикл while АБСОЛЮТНО такой же как и в пайтоне, только условие пишется в скобках.
    while (a < 10)
    {
        cout << a << " ";
        // В C++ прибавление/убавление на едиинцу можно записать как ++/--
        a++;
    }

    // Цикл for пиндос другой.
    // Имеет такой вид: for (создание переменной и присваивание значение; условие; на сколько увеличивать каждую итерацию цикла.)
    for (int i = 0; i < 10; i++)
    {
        cout << i << " ";
    }

    // Генерация случайных чисел.

    // Строка "srand(time(0))" или "srand(time(NULL))" нужна для сброса seed'а генератора псевдорандома.
    // БЕЗ НЕЕ РАБОТАТЬ НЕ БУДЕТ.
    srand(time(0));

    // Для создания случайного числа нужна функция "rand()"
    int a = rand();
    cout << a;

    // Так как мы не указали диапозон чисел, он будет случайным числом в размере 2^32
    // Сделаем случайное число из 100:
    int b = rand() % 100;
    cout << b;
    // Но это нам даст 100 чисел, в диапозоне от 0 до 99

    // Чтобы не морочить голову можно воспользоваться формулой, где A - начало диапозона, B - конец.
    int A = -50;
    int B = 50;

    int c = rand() % (B - A + 1) + A;
    cout << c;

    // В отличии от динамического Python, C++ имеет фиксированый размер массивов:
    // Массив объявляется так: тип название[размер]{элемент,элемент,элемент};
    int arr[10]{0, 9, 8, 7, 6, 5, 4, 1, 2, 1};

    // Можно создать пустой массив, но мы должны обязательно указать его размерность:
    int arr2[100];

    // Теперь можно забить его случайными числами:
    // Но вместо функции len() из Python, мы используем такую конструкцию из функций sizeof():
    // sizeof(название массива)/sizeof(название массива[первый элемент])
    // Функция sizeof() возвращаем нам размер массива в БАЙТАХ, поэтому можно поделить размер всего массива на размер одного элемента, и мы получим кол-во элементов.
    for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++)
    {
        arr[i] = i;
    }
    for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++)
    {
        cout << arr[i] << " ";
    }

    string str;
    // функция getline() читает полную строку вместе с пробелами, принимает два аргумента: метод ввода и переменную в которую записать значение.
    getline(cin, str);
    string str2 = "ya loh xd";

    // метод .find() принимает один аргумент: строку для поиска в тексте и возвращает индекс первого вхождения этой строки.
    cout << str2.find("loh");

    // метод .substr() принимает один или два аргумента: индекс с которого происходит чтение строки и индекс до которого нужно читать, возвращает строку между этими индексами.
    cout << str2.substr(3, 5);

    // метод .length() не принимает значений, возвращает длину строки.
    cout << str2.length();

    // функция toupper() принимает один аргумент - символ, возвращает тот же символ в верхнем регистре.
    cout << toupper(str2[3]); // есть ещё tolower(), то же самое только в нижний регистр.

    // канеш можно это всё дело скомбинировать:
    // сделаем всё слово лох в строке большими буквами
    string l = "loh";
    int xd = str2.find(l);
    for (int i = xd; i < xd + l.length(); i++)
    {
        str2[i] = toupper(str2[i]);
    }
    cout << str2;

    int a;
    cin >> a;

    // че такое свич ваще: эт оператор который позволяет выбирать между
    // несколькими разделами кода в зависимости от значения целочисленного выражения
    switch (a)
    {       // здес у нас переменная/выражение/условие (при условии возвращает true/false (1,0)), которая будет проверяца
    case 0: // в данном случае переменная "a" сравнивается с нулём.
        cout << "Ты ноль ввёл дэбил......";
        break; // break обязательный, иначе будет работать некорректно
    case 1:    // с единицей
        cout << "Идиничка";
        break;
    case 3: // с тройкой
        cout << "three)";
        break;
    }

    // опять же, могут быть выражения:
    switch (a % 2)
    { // проверим чётность/нечётность
    case 0:
        cout << "чётное";
        break;
    case 1:
        cout << "нечётное";
        break;
    }

    // либо условия, но там будет только 2 кейса: тру или фолс
    switch (a == 0)
    {
    case false: // либо вместо "false" можно взять ноль
        cout << "ЕТО НЕ НУЛЬ";
        break;
    case true: // вместо "true" можно взять любое другое число 1,2,3... так как "false" - это только ноль
        cout << "ЕТО НУЛЬ";
        break;
    }

    // buble sort
    for (int i = 0; i < N - 1; i++)
    {
        for (int j = 0; j < N - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    // двумерный массив (матрица) - это массив со строками и столбцами
    // массив объявеляется и забивается ручками вот так: (допустим 6x6)
    int arr2d[6][6] = {{1, 2, 3, 4, 5, 6}, // первый индекс - номер строки
                       {1, 2, 3, 4, 5, 6}, // второй индекс - номер столбца
                       {1, 2, 3, 4, 5, 6},
                       {1, 2, 3, 4, 5, 6},
                       {1, 2, 3, 4, 5, 6},
                       {1, 2, 3, 4, 5, 6}};

    // вывод матрицы:
    for (int i = 0; i < 6; i++)
    {
        for (int j = 0; j < 6; j++)
        {
            cout << arr2d[i][j] << ' ';
        }
        cout << endl; // эта строка нужна для перехода на новую строку после печати столбцов
    }
}